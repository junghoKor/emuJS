<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#000000">

    <link rel="manifest" href='data:application/manifest+json;base64,ewogICAgIm5hbWUiOiAiUmV0cm8gQXJjYWRlIiwKICAgICJzaG9ydF9uYW1lIjogIlJldHJvIiwKICAgICJzdGFydF91cmwiOiAiLiIsCiAgICAiZGlzcGxheSI6ICJmdWxsc2NyZWVuIiwKICAgICJiYWNrZ3JvdW5kX2NvbG9yIjogIiMwMDAwMDAiLAogICAgInRoZW1lX2NvbG9yIjogIiMwMDAwMDAiLAogICAgIm9yaWVudGF0aW9uIjogImxhbmRzY2FwZSIKfQ=='>

    <title>Retro Arcade Server</title>
    
    <style>
        /* =========================================
           1. CSS Variables & Global Reset
           ========================================= */
        :root {
            --primary-color: #E55B5B;
            --bg-color: #ECEFF1;
            --header-bg: linear-gradient(135deg, #E68A60, #D95053);
            --card-bg: #ffffff;
            --text-color: #2C3E50;
            --sub-text-color: #546E7A;
        }

        body { 
            background: var(--bg-color); 
            color: var(--text-color); 
            font-family: 'Segoe UI', 'Malgun Gothic', sans-serif; 
            margin: 0; padding: 0;
            width: 100%; height: 100%;
            overflow-x: hidden;
            overscroll-behavior: none; /* ëª¨ë°”ì¼ ìŠ¤í¬ë¡¤ ë°”ìš´ìŠ¤ ë°©ì§€ */
            touch-action: pan-y;
        }

        /* =========================================
           2. Header & Layout
           ========================================= */
        header { 
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px 25px;
            background: var(--header-bg); 
            color: white;
            box-shadow: 0 4px 12px rgba(217, 80, 83, 0.25);
            /* Safe Area ëŒ€ì‘ */
            padding-top: max(10px, env(safe-area-inset-top));
            padding-left: max(25px, env(safe-area-inset-left));
            padding-right: max(25px, env(safe-area-inset-right));
        }

        .header-title { display: flex; align-items: baseline; gap: 10px; }
        h1 { margin: 0; font-size: 1.3rem; letter-spacing: 0.5px; text-shadow: 1px 1px 2px rgba(0,0,0,0.1); }
        
        #system-info { font-size: 0.85rem; color: rgba(255,255,255,0.95); font-family: monospace; }
        #system-info span { color: #fff; font-weight: bold; background: rgba(0,0,0,0.15); padding: 2px 6px; border-radius: 4px;}

        /* =========================================
           3. Buttons
           ========================================= */
        .btn-group { display: flex; gap: 10px; }
        .btn {
            background: #fff; color: #D95053; padding: 6px 14px; font-size: 0.85rem;
            border: none; border-radius: 20px;
            cursor: pointer; font-weight: bold; transition: all 0.2s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.08);
            display: flex; align-items: center; gap: 5px;
        }
        .btn:hover { background: #fff5f5; transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.12); }
        .btn-yellow { color: #F57C00; }
        .btn-yellow:hover { background: #FFF3E0; }

        /* =========================================
           4. Game List & Cards
           ========================================= */
        .category { padding: 10px 25px; animation: fadeIn 0.4s ease-out; }
        .category-title { 
            font-size: 1.0rem; color: var(--text-color); 
            border-left: 5px solid var(--primary-color); 
            padding-left: 10px; margin: 15px 0 8px 0; 
            text-transform: uppercase; font-weight: 800;
            display: flex; align-items: center;
        }
        .game-count {
            font-size: 0.8rem; color: #78909C; margin-left: 8px; font-weight: normal;
            background: #CFD8DC; padding: 1px 6px; border-radius: 10px;
        }

        .rom-grid { 
            display: grid; 
            grid-template-columns: repeat(auto-fill, minmax(130px, 1fr)); 
            gap: 8px;
        }

        /* [ìˆ˜ì •] ROM Card: íŒ¨ë”© ë° ì •ë ¬ ì •ë°€ ì¡°ì • */
        .rom-card { 
            background: var(--card-bg); 
            /* í•˜ë‹¨ íŒ¨ë”© 14px: í…ìŠ¤íŠ¸(ì•½ 12px) + ê°„ê²© + ê²Œì´ì§€(2px) + ì—¬ë°±(8px) í™•ë³´ */
            padding: 8px 10px 14px 10px; 
            border-radius: 6px; 
            text-align: center; cursor: pointer; 
            border: 1px solid #E0E0E0;
            transition: all 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);
            
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            
            box-shadow: 0 2px 4px rgba(0,0,0,0.04);
            position: relative; 
            
            /* í…ìŠ¤íŠ¸ ì„ íƒ ë° ë¡±í”„ë ˆìŠ¤ ë©”ë‰´ ë°©ì§€ */
            user-select: none; -webkit-user-select: none; -webkit-touch-callout: none;
        }

        .rom-card:hover { 
            border-color: var(--primary-color); transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(229, 91, 91, 0.15);
        }
        .rom-card.last-played {
            background: #F1F8E9; border: 2px solid #7CB342;
            transform: translateY(-2px); box-shadow: 0 4px 8px rgba(124, 179, 66, 0.3);
        }
        
        .rom-name { 
            font-weight: 600; word-break: break-all; font-size: 0.8rem; 
            line-height: 1.25; color: var(--text-color);
            margin-bottom: 2px; /* ê²Œì´ì§€ì™€ì˜ ìµœì†Œ ê°„ê²© */
        }

        /* Badge */
        .last-played-badge {
            position: absolute; top: -8px; right: -5px;
            background: #7CB342; color: white;
            font-size: 0.7rem; font-weight: bold;
            padding: 2px 8px; border-radius: 12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            z-index: 10; animation: bounceIn 0.5s;
        }
        
        /* [ìˆ˜ì •] ê²Œì´ì§€ ì»¨í…Œì´ë„ˆ: 2px ê°•ì œ ê³ ì • ë° ìœ„ì¹˜ ì„¤ì • */
        .size-gauge {
            position: absolute; 
            bottom: 6px;  /* í•˜ë‹¨ì—ì„œ 6px ìœ„ */
            left: 10px;   /* ì¹´ë“œ íŒ¨ë”©ê³¼ ë™ì¼ */
            right: 10px; 
            
            /* ë†’ì´ ê°•ì œ ê³ ì • (flex ì•„ì´í…œ ì˜í–¥ ë°©ì§€) */
            height: 2px !important;
            min-height: 2px;
            max-height: 2px;
            line-height: 0;
            font-size: 0;
            
            border-radius: 1px;
            overflow: hidden;
            
            /* [í•µì‹¬] ë°°ê²½: ì¢Œì¸¡(Red) <-> ìš°ì¸¡(Green) ì „ì²´ ê·¸ë¼ë°ì´ì…˜ */
            /* íŒŒì¼ì´ í´ìˆ˜ë¡(ê°€ë¦¼ë§‰ì´ ì¤„ì–´ë“¤ìˆ˜ë¡) ì™¼ìª½ì˜ ë¹¨ê°„ìƒ‰ì´ ë“œëŸ¬ë‚¨ */
            background: linear-gradient(to right, #FF1744, #FFEA00, #00E676);
            z-index: 1;
        }
        
        /* [ìˆ˜ì •] ê°€ë¦¼ë§‰: ì™¼ìª½ë¶€í„° ë®ì–´ì„œ ìš©ëŸ‰ í‘œí˜„ */
        .gauge-cover {
            position: absolute;
            top: 0;
            left: 0; /* ì™¼ìª½ë¶€í„° ì‹œì‘ */
            height: 100%;
            background-color: #EEEEEE; /* ë¹„ì–´ìˆëŠ” êµ¬ê°„ ìƒ‰ìƒ (ì¹´ë“œ ë°°ê²½ê³¼ êµ¬ë¶„) */
            z-index: 2; /* ê·¸ë¼ë°ì´ì…˜ ìœ„ì— ë®ê¸° */
            transition: width 0.3s ease;
        }

        /* =========================================
           5. Game View Overlay
           ========================================= */
        #game-view { 
            display: none; 
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            width: 100%; height: 100%;
            background: #000; z-index: 1000;
            cursor: none; 
        }
        #game-view.show-cursor { cursor: default; }

        .game-ctrl-btn {
            position: absolute; top: 10px; z-index: 2000;
            background: transparent; border: none; cursor: pointer;
            opacity: 0.1; transition: opacity 0.3s, transform 0.2s;
            padding: 10px; pointer-events: auto;
            top: max(10px, env(safe-area-inset-top));
        }
        .game-ctrl-btn:hover { opacity: 1.0; transform: scale(1.1); }
        .game-ctrl-btn svg { width: 40px; height: 40px; fill: white; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5)); }

        #refresh-btn {
            right: max(10px, env(safe-area-inset-right));
        }
        #refresh-btn svg { width: 80px; height: 80px; }
        
        #fs-check-btn {
            right: max(60px, env(safe-area-inset-right));
            display: none !important;
        }

        /* =========================================
           6. Components
           ========================================= */
        #toast {
            visibility: hidden; min-width: 250px;
            background-color: rgba(20, 20, 20, 0.6); 
            backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
            color: #fff; text-align: center;
            border-radius: 8px; padding: 12px 24px; 
            position: fixed; z-index: 2000; left: 50%; bottom: 30px; 
            transform: translateX(-50%) translateY(20px);
            box-shadow: 0 4px 16px rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.08);
            opacity: 0; transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
            font-size: 0.95rem; font-weight: 500; white-space: pre-line;
            pointer-events: none;
        }
        #toast.show { visibility: visible; opacity: 1; bottom: 50px; transform: translateX(-50%) translateY(0); }

        #context-menu {
            display: none; position: absolute; z-index: 3000;
            background: white; border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2); padding: 5px 0;
            min-width: 150px; overflow: hidden; border: 1px solid #eee;
        }
        .ctx-item {
            padding: 10px 15px; font-size: 0.9rem; color: #333; cursor: pointer;
            display: flex; align-items: center; gap: 8px; transition: background 0.2s;
        }
        .ctx-item:hover { background-color: #f5f5f5; color: var(--primary-color); }
        .ctx-item.delete { color: #e74c3c; }
        .ctx-item.delete:hover { background-color: #ffebee; }
        .icon { width: 16px; text-align: center; }

        .modal-overlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); z-index: 4000;
            justify-content: center; align-items: center;
        }
        .modal-box {
            background: white; padding: 20px; border-radius: 12px;
            width: 300px; text-align: center;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5); animation: fadeIn 0.2s;
        }
        .modal-title { margin: 0 0 15px 0; font-size: 1.1rem; color: #D95053; font-weight: bold; }
        .modal-desc { margin-bottom: 20px; font-size: 0.9rem; color: #555; word-break: break-all;}
        .modal-input {
            width: 80%; padding: 10px; margin-bottom: 15px;
            border: 2px solid #ddd; border-radius: 8px; font-size: 1rem; text-align: center;
        }
        .modal-input:focus { border-color: var(--primary-color); outline: none; }
        .modal-btns { display: flex; gap: 10px; justify-content: center; }

        #fs-modal .modal-box {
            width: 85%; max-width: 600px; height: 70vh;
            display: flex; flex-direction: column;
        }
        #fs-content {
            flex: 1; text-align: left; background: #f1f3f4; 
            padding: 10px; margin: 10px 0; border-radius: 4px;
            border: 1px solid #ccc; overflow: auto; 
            font-family: monospace; font-size: 12px;
            white-space: pre;
            user-select: text; -webkit-user-select: text; 
        }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes bounceIn { 0% { transform: scale(0); } 80% { transform: scale(1.1); } 100% { transform: scale(1.1); } }
    </style>
</head>
<body>

<div id="main-ui">
    <header>
        <div class="header-title">
            <h1>ğŸ‘¾ RETRO ARCADE</h1>
            <span id="system-info">Loading...</span>
        </div>
        <div class="btn-group">
            <button id="view-toggle-btn" class="btn btn-yellow" onclick="App.toggleView()">â˜… ì¦ê²¨ì°¾ê¸°</button>
            <button class="btn" onclick="App.downloadCores()">ğŸ“¥ ì½”ì–´ ë™ê¸°í™”</button>
        </div>
    </header>
    <div id="content"><!-- SERVER_RENDERED_CONTENT --></div>
</div>

<div id="game-view">
    <button id="fs-check-btn" class="game-ctrl-btn" onclick="App.checkFS()" title="íŒŒì¼ ì‹œìŠ¤í…œ í™•ì¸">
        <svg viewBox="0 0 24 24">
            <path d="M20 6h-8l-2-2H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm-5 3c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2zm4 8h-8v-1c0-1.33 2.67-2 4-2s4 .67 4 2v1z"/>
        </svg>
    </button>
    
    <button id="refresh-btn" class="game-ctrl-btn" onclick="App.closeGame()" title="ë‚˜ê°€ê¸°">
        <svg viewBox="0 0 24 24">
            <path d="M17 7l-1.41 1.41L18.17 11H8v2h10.17l-2.58 2.58L17 17l5-5zM4 5h8V3H4c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h8v-2H4V5z"/>
        </svg>
    </button>
    <div id="game" style="width:100%; height:100%;"></div>
</div>

<div id="toast"></div>
<div id="context-menu"></div>

<div id="password-modal" class="modal-overlay">
    <div class="modal-box">
        <h3 class="modal-title">âš ï¸ íŒŒì¼ ì‚­ì œ í™•ì¸</h3>
        <p id="modal-desc" class="modal-desc"></p>
        <input type="password" id="modal-pw" class="modal-input" placeholder="ë¹„ë°€ë²ˆí˜¸ ì…ë ¥" maxlength="10">
        <div class="modal-btns">
            <button class="btn" onclick="App.execDelete()">ì‚­ì œ</button>
            <button class="btn" onclick="App.closeModal()">ì·¨ì†Œ</button>
        </div>
    </div>
</div>

<div id="fs-modal" class="modal-overlay">
    <div class="modal-box">
        <h3 class="modal-title">ğŸ“‚ File System Structure</h3>
        <div id="fs-content"></div>
        <div class="modal-btns">
            <button class="btn" onclick="App.closeFSModal()">ë‹«ê¸°</button>
        </div>
    </div>
</div>

<script>
    const coreMap = { 
        neogeo: "fbneo",
        fbneo:  "fbneo", 
        mame:   "mame2003_plus", 
        snes:   "snes9x", 
        gba:    "mgba", 
        nds:    "melonds",
        psx:    "mednafen_psx_hw"
    };

    const CORE_FOLDER_MAP = {
        'mgba': 'mGBA',      
        'melonds': 'melonDS' 
    };

    const CONFIG = {
        biosMap: {
            neogeo: "", 
            psx:    "/data/bios/scph5501.bin"
        },
        useAdditionalFiles: false,
        paths: {
            roms: "/data/roms",
            ejsData: "/emulatorjs/data/" 
        }
    };

    const INJECT = {
        neogeo: [ "/data/bios/neogeo_small.zip" ]
    };

    function showToast(message, isError = false) {
        const toast = document.getElementById("toast");
        toast.innerText = message;
        toast.style.color = isError ? "#FFCDD2" : "#E8F5E9";
        toast.style.borderColor = isError ? "rgba(239, 83, 80, 0.4)" : "rgba(102, 187, 106, 0.4)";
        toast.className = "show";
        setTimeout(() => { toast.className = toast.className.replace("show", ""); }, 1500);
    }

    const App = {
        currentView: 'library', 
        cachedRoms: null,       
        inGame: false,          
        deleteTarget: null,     
        cursorTimer: null,
        serverHtml: "",      
        isLongPress: false, 
        
        init: function() {
            if ('scrollRestoration' in history) {
                history.scrollRestoration = 'manual';
            }

            this.updateSystemInfo();

            const contentDiv = document.getElementById('content');
            if (contentDiv && contentDiv.innerHTML.trim().length > 0) {
                this.serverHtml = contentDiv.innerHTML;
            }

            const lastView = localStorage.getItem('lastViewMode');
            if (lastView === 'bookmark') {
                this.loadBookmarks();
            } else {
                this.currentView = 'library';
                localStorage.setItem('lastViewMode', 'library');
                this.applyLastPlayedStyle();
            }
            this.setupCursorControl();
            this.setupListFullscreen();

            document.addEventListener('click', () => {
                if (this.inGame) return; 
                const menu = document.getElementById('context-menu');
                if (menu.style.display === 'block') menu.style.display = 'none';
            });
        },

        setupListFullscreen: function() {
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
            if (!isIOS) return;

            const enterFullscreen = () => {
                if (this.inGame || document.fullscreenElement || document.webkitFullscreenElement) return;

                const doc = document.documentElement;
                if (doc.webkitRequestFullscreen) {
                    doc.webkitRequestFullscreen();
                } else if (doc.requestFullscreen) {
                    doc.requestFullscreen().catch(() => {});
                }
            };

            const events = ['touchstart', 'click'];
            const handler = () => {
                enterFullscreen();
                events.forEach(ev => document.body.removeEventListener(ev, handler));
            };

            events.forEach(ev => document.body.addEventListener(ev, handler, { passive: true }));
        },

        setupCursorControl: function() {
            const view = document.getElementById('game-view');
            view.addEventListener('mousemove', () => {
                view.classList.add('show-cursor');
                if (this.cursorTimer) clearTimeout(this.cursorTimer);
                this.cursorTimer = setTimeout(() => {
                    view.classList.remove('show-cursor');
                }, 3000);
            }, { passive: true });
        },

        updateSystemInfo: async function() {
            try {
                const res = await fetch('/api/disk');
                if (!res.ok) throw new Error("Network error");
                const data = await res.json();
                const toGB = (b) => (b / (1024**3)).toFixed(1);
                const percent = ((data.free / data.total) * 100).toFixed(1);
                document.getElementById('system-info').innerHTML = 
                    `DISK FREE <span>${toGB(data.free)}G</span>/${toGB(data.total)}G (${percent}%)`;
            } catch (e) { console.error("Disk info error:", e); }
        },

        toggleView: function() {
            if (this.currentView === 'library') this.loadBookmarks();
            else this.loadLibrary();
        },

        loadLibrary: function() {
            this.currentView = 'library';
            localStorage.setItem('lastViewMode', 'library');

            const btn = document.getElementById('view-toggle-btn');
            if(btn) btn.innerText = "â˜… ì¦ê²¨ì°¾ê¸°";

            const container = document.getElementById('content');
            
            if (this.serverHtml) {
                container.innerHTML = this.serverHtml;
                this.applyLastPlayedStyle();
            } else {
                container.innerHTML = '<div style="padding:20px; text-align:center; color:#888;">ë¡œë”© ì¤‘ì´ê±°ë‚˜ ê²Œì„ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.</div>';
            }
        },

        loadBookmarks: async function() {
            this.currentView = 'bookmark';
            localStorage.setItem('lastViewMode', 'bookmark');

            const btn = document.getElementById('view-toggle-btn');
            if(btn) btn.innerText = "ğŸ“š ëª¨ë‘ë³´ê¸°";

            const container = document.getElementById('content');
            
            try {
                const res = await fetch('/api/bookmark?format=html');
                const html = await res.text();
                
                container.innerHTML = html;
                this.applyLastPlayedStyle();

            } catch (e) {
                container.innerHTML = '<div style="text-align:center; padding:50px; color:#aaa;">ë¡œë”© ì‹¤íŒ¨</div>';
                showToast("ì¦ê²¨ì°¾ê¸° ë¡œë“œ ì‹¤íŒ¨", true);
            }
        },

        // [ìˆ˜ì •] í´ë¼ì´ì–¸íŠ¸ ì‚¬ì´ë“œ ì¹´ë“œ ìƒì„± í•¨ìˆ˜ (ë™ê¸°í™”)
        createCard: function(sys, romData) {
            let romName, romSize = 0;
            if (typeof romData === 'object' && romData !== null) {
                romName = romData.name;
                romSize = romData.size || 0;
            } else {
                romName = romData;
            }

            const card = document.createElement('div');
            card.className = 'rom-card';
            card.setAttribute('data-sys', sys);
            card.setAttribute('data-rom', romName);
            
            card.innerHTML = `<span class="rom-name">${romName.replace(/\.[^/.]+$/, "").toUpperCase()}</span>`;
            
            if (romSize > 0) {
                const gauge = document.createElement('div');
                gauge.className = 'size-gauge';
                
                // 20MB ê¸°ì¤€ (Server Logicê³¼ ë™ì¼)
                const mb = romSize / (1024 * 1024);
                let percent = Math.min(100, (mb / 20.0) * 100);
                if (percent < 5) percent = 5;
                
                // ê°€ë¦¼ë§‰ ë°©ì‹: Coverì˜ ë„ˆë¹„ = 100 - percent
                const coverPercent = 100 - percent;

                const cover = document.createElement('div');
                cover.className = 'gauge-cover';
                cover.style.width = coverPercent + '%';
                
                gauge.appendChild(cover);
                card.appendChild(gauge);
            }
            
            let longPressTimer;
            let isLongPress = false;

            card.addEventListener('touchstart', (e) => {
                isLongPress = false; 
                longPressTimer = setTimeout(() => {
                    isLongPress = true; 
                    if (navigator.vibrate) navigator.vibrate(50);
                    const touch = e.touches[0];
                    this.showContextMenu(touch.pageX, touch.pageY, sys, romName);
                }, 1000); 
            }, { passive: true });

            card.addEventListener('touchend', () => clearTimeout(longPressTimer));
            card.addEventListener('touchmove', () => clearTimeout(longPressTimer));

            card.onclick = () => {
                if (isLongPress) { isLongPress = false; return; }
                Launcher.run(sys, romName);
            };

            card.oncontextmenu = (e) => {
                e.preventDefault();
                this.showContextMenu(e.pageX, e.pageY, sys, romName);
            };
            
            return card;
        },

        addBadge: function(card) {
            if (card.querySelector('.last-played-badge')) return;
            const badge = document.createElement('div');
            badge.className = 'last-played-badge';
            badge.innerText = "â–¶ LAST";
            card.appendChild(badge);
        },

        showContextMenu: function(x, y, sys, rom) {
            const menu = document.getElementById('context-menu');
            menu.style.display = 'block';
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';

            const safeSys = sys.replace(/'/g, "\\'");
            const safeRom = rom.replace(/'/g, "\\'");
            let html = '';

            if (this.currentView === 'library') {
                html += `<div class="ctx-item" onclick="App.addBookmark('${safeSys}', '${safeRom}')"><span class="icon">â˜…</span> ì¦ê²¨ì°¾ê¸° ì¶”ê°€</div>`;
                html += `<div class="ctx-item delete" onclick="App.deleteRom('${safeSys}', '${safeRom}')"><span class="icon">ğŸ—‘ï¸</span> íŒŒì¼ ì‚­ì œ</div>`;
            } else {
                html += `<div class="ctx-item" onclick="App.removeBookmark('${safeSys}', '${safeRom}')"><span class="icon">ğŸ’”</span> ì¦ê²¨ì°¾ê¸° í•´ì œ</div>`;
            }
            menu.innerHTML = html;
        },

        showCtx: function(e, sys, rom) {
            e.preventDefault();
            this.showContextMenu(e.pageX, e.pageY, sys, rom);
        },

        handleTouch: function(e, sys, rom) {
            this.isLongPress = false;
            const target = e.currentTarget;
            
            const timer = setTimeout(() => {
                this.isLongPress = true;
                if (navigator.vibrate) navigator.vibrate(50);
                if (e.touches && e.touches[0]) {
                    this.showContextMenu(e.touches[0].pageX, e.touches[0].pageY, sys, rom);
                }
            }, 800);

            const clear = () => {
                clearTimeout(timer);
                target.removeEventListener('touchend', clear);
                target.removeEventListener('touchmove', clear);
            };

            target.addEventListener('touchend', clear);
            target.addEventListener('touchmove', clear);
        },

        applyLastPlayedStyle: function() {
             try {
                document.querySelectorAll('.last-played').forEach(el => el.classList.remove('last-played'));
                document.querySelectorAll('.last-played-badge').forEach(el => el.remove());
                const oldTarget = document.getElementById('last-played-target');
                if(oldTarget) oldTarget.removeAttribute('id');

                const globalLast = JSON.parse(localStorage.getItem('lastPlayedGlobal'));
                
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key.startsWith('lastPlayedLocal_')) {
                        const sys = key.replace('lastPlayedLocal_', '');
                        const rom = localStorage.getItem(key);
                        
                        const safeSys = sys.replace(/["\\]/g, '\\$&'); 
                        const safeRom = rom.replace(/["\\]/g, '\\$&');
                        
                        const selector = `.rom-card[data-sys="${safeSys}"][data-rom="${safeRom}"]`;
                        const target = document.querySelector(selector);
                        
                        if (target) {
                            this.addBadge(target);
                        }
                    }
                }

                if (globalLast && globalLast.sys && globalLast.rom) {
                    const safeSys = globalLast.sys.replace(/["\\]/g, '\\$&');
                    const safeRom = globalLast.rom.replace(/["\\]/g, '\\$&');
                    const selector = `.rom-card[data-sys="${safeSys}"][data-rom="${safeRom}"]`;
                    
                    setTimeout(() => {
                        const target = document.querySelector(selector);
                        if (target) {
                             target.classList.add('last-played');
                             target.id = 'last-played-target';
                             this.addBadge(target); 
                             target.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                    }, 100);
                }
             } catch(e) { console.error("Style apply error", e); }
        },

        addBookmark: async function(sys, rom) {
            try {
                await fetch('/api/bookmark', { method: 'POST', body: JSON.stringify({ system: sys, rom: rom }) });
                showToast("â˜… ì¦ê²¨ì°¾ê¸°ì— ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤!");
            } catch(e) { showToast("ì¶”ê°€ ì‹¤íŒ¨", true); }
        },

        removeBookmark: async function(sys, rom) {
            try {
                await fetch('/api/bookmark', { method: 'DELETE', body: JSON.stringify({ system: sys, rom: rom }) });
                showToast("ğŸ’” ì¦ê²¨ì°¾ê¸° í•´ì œ ì™„ë£Œ");
                this.loadBookmarks(); 
            } catch(e) { showToast("í•´ì œ ì‹¤íŒ¨", true); }
        },

        deleteRom: function(sys, rom) {
            this.deleteTarget = { sys, rom };
            const modal = document.getElementById('password-modal');
            const desc = document.getElementById('modal-desc');
            const input = document.getElementById('modal-pw');
            
            desc.innerText = `${rom}\níŒŒì¼ì„ ì˜êµ¬ì ìœ¼ë¡œ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`;
            input.value = ''; 
            modal.style.display = 'flex'; 
            input.focus();
        },

        closeModal: function() {
            document.getElementById('password-modal').style.display = 'none';
            this.deleteTarget = null;
        },

        execDelete: async function() {
            const input = document.getElementById('modal-pw');
            if (input.value !== "1") {
                showToast("â›” ë¹„ë°€ë²ˆí˜¸ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.", true);
                input.value = ''; input.focus();
                return;
            }

            if (!this.deleteTarget) return;
            const { sys, rom } = this.deleteTarget;
            this.closeModal();

            try {
                const safeRom = encodeURIComponent(rom).replace(/[!'()*]/g, function(c) {
                    return '%' + c.charCodeAt(0).toString(16);
                });
                const res = await fetch(`/api/rom?sys=${encodeURIComponent(sys)}&rom=${safeRom}`, { method: 'DELETE' });
                
                if (res.ok) {
                    showToast("ğŸ—‘ï¸ íŒŒì¼ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.");
                    location.reload(); 
                } else { showToast("ì‚­ì œ ì‹¤íŒ¨ (ì„œë²„ ì˜¤ë¥˜)", true); }
            } catch(e) { showToast("ì˜¤ë¥˜ ë°œìƒ", true); }
        },

        downloadCores: async function() {
            const btn = document.querySelector('.btn-group .btn:last-child');
            const originText = btn.innerText;
            btn.innerText = "â³ ë‹¤ìš´ë¡œë“œ ì¤‘...";
            btn.disabled = true;
            try {
                const res = await fetch('/api/download-cores');
                const msg = await res.text();
                
                const versionMatch = msg.match(/\[VERSION:(\d+)\]/);
                if (versionMatch && versionMatch[1]) {
                    localStorage.setItem('coreVersion', versionMatch[1]);
                }
                alert(msg.replace(/\[VERSION:\d+\]/, "")); 
            } catch (err) { alert("í†µì‹  ì‹¤íŒ¨: " + err); } 
            finally { btn.innerText = originText; btn.disabled = false; }
        },

        closeGame: function() {
            if (Launcher.monitorInterval) {
                clearInterval(Launcher.monitorInterval);
                Launcher.monitorInterval = null;
            }
            App.inGame = false;

            try {
                if (document.fullscreenElement || document.webkitFullscreenElement) {
                    if (document.exitFullscreen) document.exitFullscreen();
                    else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
                }
            } catch(e) { console.error("Exit Fullscreen error:", e); }

            location.reload(); 
        },

        checkFS: function() {
            if (!window.EJS_emulator || !window.EJS_emulator.Module || !window.EJS_emulator.Module.FS) {
                alert("Emulator FSê°€ ì•„ì§ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
                return;
            }

            const FS = window.EJS_emulator.Module.FS;
            let output = "=== FS Structure (/) ===\n";
            let count = 0;
            const MAX_ITEMS = 5000; 

            function walk(dir, level) {
                if (count > MAX_ITEMS) return;

                try {
                    const files = FS.readdir(dir);
                    files.sort(); 

                    for (const file of files) {
                        if (file === '.' || file === '..') continue;
                        if (count > MAX_ITEMS) {
                            output += `\n... (ì¶œë ¥ ì œí•œ ì´ˆê³¼: ${MAX_ITEMS}ê°œ ì´ìƒ)\n`;
                            return;
                        }

                        const fullPath = dir === '/' ? '/' + file : dir + '/' + file;
                        let stat;
                        try { stat = FS.stat(fullPath); } catch(e) { continue; }

                        const indent = "  ".repeat(level);
                        
                        if (FS.isDir(stat.mode)) {
                            output += `${indent}ğŸ“‚ ${file}\n`;
                            walk(fullPath, level + 1);
                        } else {
                            output += `${indent}ğŸ“„ ${file} (${stat.size} b)\n`;
                            count++;
                        }
                    }
                } catch (e) {
                    output += "  ".repeat(level) + `[Access Denied] ${dir}\n`;
                }
            }

            walk('/', 0);
            
            document.getElementById('fs-content').textContent = output || "ë¹„ì–´ìˆìŒ";
            document.getElementById('fs-modal').style.display = 'flex';
        },

        closeFSModal: function() {
            document.getElementById('fs-modal').style.display = 'none';
        },

        restoreMainView: function() {
            const btnRefresh = document.getElementById('refresh-btn');
            const btnFS = document.getElementById('fs-check-btn');
            const view = document.getElementById('game-view');
            
            if(view) {
                if(btnRefresh && btnRefresh.parentElement !== view) view.appendChild(btnRefresh);
                if(btnFS && btnFS.parentElement !== view) view.appendChild(btnFS);
            }

            document.getElementById('game-view').style.display = 'none';
            document.getElementById('main-ui').style.display = 'block';

            Launcher.cleanup();
            App.inGame = false;
        }
    };

    const LocalStateStore = {
        dbName: 'RetroArcade_States',
        storeName: 'states',
        db: null,

        init: function() {
            return new Promise((resolve, reject) => {
                if (this.db) return resolve(this.db);
                
                if (!window.indexedDB) {
                    alert("ì´ ë¸Œë¼ìš°ì €ëŠ” IndexedDBë¥¼ ì§€ì›í•˜ì§€ ì•Šê±°ë‚˜ ì°¨ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤. (ì‹œí¬ë¦¿ ëª¨ë“œ í•´ì œ í•„ìš”)");
                    return reject("IndexedDB not supported");
                }

                const request = indexedDB.open(this.dbName, 1);
                
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains(this.storeName)) {
                        db.createObjectStore(this.storeName);
                    }
                };
                
                request.onsuccess = (e) => {
                    this.db = e.target.result;
                    resolve(this.db);
                };
                
                request.onerror = (e) => {
                    console.error("ğŸ”¥ IndexedDB Open Error:", e.target.error);
                    reject(e.target.error);
                };
            });
        },

        save: async function(key, data) {
            try {
                await this.init();
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction(this.storeName, 'readwrite');
                    const store = tx.objectStore(this.storeName);
                    
                    if (!data) {
                        console.error("âŒ ì €ì¥í•  ë°ì´í„°ê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.");
                        return reject("Empty Data");
                    }

                    const req = store.put(data, key);
                    
                    req.onsuccess = () => resolve(true);
                    req.onerror = (e) => {
                        console.error("ğŸ”¥ IDB Put Error:", e.target.error);
                        reject(e.target.error);
                    };
                });
            } catch (err) {
                console.error("ğŸ”¥ LocalStateStore Save Exception:", err);
                return false;
            }
        },

        load: async function(key) {
            try {
                await this.init();
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction(this.storeName, 'readonly');
                    const store = tx.objectStore(this.storeName);
                    const req = store.get(key);
                    
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = (e) => {
                        console.error("ğŸ”¥ IDB Get Error:", e.target.error);
                        resolve(null);
                    };
                });
            } catch (err) { return null; }
        }
    };

    const Launcher = {
        monitorInterval: null,
        currentSavePath: null,
        lastSaveMtime: 0,
        isSaving: false,

        run: async function(sys, rom) {
            if (App.isLongPress) {
                App.isLongPress = false;
                return;
            }

            App.inGame = true;
            if (document.activeElement) document.activeElement.blur();
            window.focus();

            const newGameName = `${sys}-${rom}`;
            
            try {
                localStorage.setItem('lastPlayedGlobal', JSON.stringify({ sys: sys, rom: rom }));
                localStorage.setItem('lastPlayedLocal_' + sys, rom);
            } catch (e) {}

            if (window.EJS_gameName && window.EJS_gameName !== newGameName) this.cleanup();

            document.getElementById('main-ui').style.display = 'none';
            document.getElementById('game-view').style.display = 'block';
            document.getElementById('game-view').classList.remove('show-cursor');
            window.scrollTo(0, 0); 

            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
            if (isIOS) {
                const doc = document.documentElement; 
                if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();
                else if (doc.requestFullscreen) doc.requestFullscreen().catch(() => {});
            }

            const gameEl = document.getElementById('game');
            gameEl.style.height = '100%'; gameEl.style.width = '100%';
            
            const selectedCore = coreMap[sys] || "fbneo";
            if (this.monitorInterval) { clearInterval(this.monitorInterval); this.monitorInterval = null; }

            const oldLoader = document.getElementById('ejs-loader');
            if (oldLoader) oldLoader.remove();
            
            gameEl.innerHTML = ''; 

            window.EJS_player = "#game";
            window.EJS_core = selectedCore;
            window.EJS_gameName = newGameName;
            window.EJS_DEBUG_XX = true;
            window.EJS_disableDatabases = false;
            
            window.EJS_paths = {
                "loader.js":        "/emulatorjs/data/loader.js",
                "version.json":     "/emulatorjs/data/version.json",
                "GameManager.js":   "/emulatorjs/data/src/GameManager.js",
                "gamepad.js":       "/emulatorjs/data/src/gamepad.js",
                "nipplejs.js":      "/emulatorjs/data/src/nipplejs.js",
                "shaders.js":       "/emulatorjs/data/src/shaders.js",
                "socket.io.min.js": "/emulatorjs/data/src/socket.io.min.js",
                "storage.js":       "/emulatorjs/data/src/storage.js",
                "emulator.js":      "/emulatorjs/data/src/emulator.js",
                "emulator.css":     "/emulatorjs/data/emulator.css",
                "compression.js":   "/emulatorjs/data/src/compression.js",
                "fflate.min.js":    "/emulatorjs/data/src/fflate.min.js",
            };
            
            window.EJS_pathtodata = CONFIG.paths.ejsData;
            window.EJS_coreUrl = window.EJS_pathtodata + "cores/"; 
            
            if (INJECT[sys] && INJECT[sys].length > 0) {
                showToast("âš™ï¸ BIOS ë³‘í•© í™•ì¸ ì¤‘...", false);
                try {
                    const injectPaths = INJECT[sys].join(',');
                    const res = await fetch(`/api/rom/inject?sys=${sys}&rom=${rom}&inject=${encodeURIComponent(injectPaths)}`);
                    if (!res.ok) throw new Error("Inject request failed");
                    console.log("[Launcher] Inject sync complete.");
                } catch (e) {
                    console.error("[Launcher] Injection error:", e);
                    showToast("âš ï¸ ë³‘í•© ì‹¤íŒ¨. ì›ë³¸ìœ¼ë¡œ ì‹¤í–‰í•©ë‹ˆë‹¤.", true);
                }
            }

            window.EJS_gameUrl = `${CONFIG.paths.roms}/${sys}/${rom}`;
            window.EJS_biosUrl = null;
            window.EJS_externalFiles = null;

            window.EJS_fixedSaveInterval = 120000;
            window.EJS_gamepad = true;

			if (sys === 'nds' || sys === 'neogeo' || sys === 'gba' ) {
				window.EJS_defaultControls = {
					0: {
						0: { 'value': 'x', 'value2': 'BUTTON_2' },
						1: { 'value': 's', 'value2': 'RIGHT_BOTTOM_SHOULDER' },
						2: { 'value': 'v', 'value2': 'SELECT' },
						3: { 'value': 'enter', 'value2': 'START' },
						4: { 'value': 'up arrow', 'value2': 'LEFT_STICK_Y:-1' },
						5: { 'value': 'down arrow', 'value2': 'LEFT_STICK_Y:+1' },
						6: { 'value': 'left arrow', 'value2': 'LEFT_STICK_X:-1' },
						7: { 'value': 'right arrow', 'value2': 'LEFT_STICK_X:+1' },
						8: { 'value': 'z', 'value2': 'BUTTON_1' },
						9: { 'value': 'a', 'value2': 'BUTTON_3' },
						10: { 'value': 'q', 'value2': 'LEFT_TOP_SHOULDER' },
						11: { 'value': 'e', 'value2': 'LEFT_BOTTOM_SHOULDER' },
						12: { 'value': 'tab' },
						13: { 'value': 'r' },
						16: { 'value': 'h', 'value2': 'DPAD_RIGHT' },
						17: { 'value': '', 'value2': 'DPAD_LEFT' },
						18: { 'value': '', 'value2': 'DPAD_DOWN' },
						19: { 'value': '', 'value2': 'DPAD_UP' },
						24: { 'value': '1' },
						25: { 'value': '2' },
						26: { 'value': '3' },
						27: { 'value': 'add', 'value2': 'GAMEPAD_16' },
						28: { 'value': 'space' },
						29: { 'value': 'subtract' }
					},
					1: {}, 2: {}, 3: {}
				};
			} else { 
				window.EJS_defaultControls = {
					0: {
						0: { 'value': 'x', 'value2': 'BUTTON_1' },
						1: { 'value': 's', 'value2': 'BUTTON_3' },
						2: { 'value': 'v', 'value2': 'SELECT' },
						3: { 'value': 'enter', 'value2': 'START' },
						4: { 'value': 'up arrow', 'value2': 'LEFT_STICK_Y:-1' },
						5: { 'value': 'down arrow', 'value2': 'LEFT_STICK_Y:+1' },
						6: { 'value': 'left arrow', 'value2': 'LEFT_STICK_X:-1' },
						7: { 'value': 'right arrow', 'value2': 'LEFT_STICK_X:+1' },
						8: { 'value': 'z', 'value2': 'BUTTON_2' },
						9: { 'value': 'a', 'value2': 'BUTTON_4' },
						10: { 'value': 'q', 'value2': 'RIGHT_TOP_SHOULDER' },
						11: { 'value': 'e', 'value2': 'RIGHT_BOTTOM_SHOULDER' },
						12: { 'value': 'tab' },
						13: { 'value': 'r' },
						16: { 'value': 'h', 'value2': 'DPAD_RIGHT' },
						17: { 'value': '', 'value2': 'DPAD_LEFT' },
						18: { 'value': '', 'value2': 'DPAD_DOWN' },
						19: { 'value': '', 'value2': 'DPAD_UP' },
						24: { 'value': '1' },
						25: { 'value': '2' },
						26: { 'value': '3' },
						27: { 'value': 'add', 'value2': 'GAMEPAD_16' },
						28: { 'value': 'space' },
						29: { 'value': 'subtract' }
					},
					1: {}, 2: {}, 3: {}
				};
			}
			
            window.EJS_defaultOptions = {
                'shader': 'crt-easymode.glslp',
                'save-state-location': 'memory', 
                'worker': 'false', 
                'webgl2Enabled': 'enabled',
            };
            
            window.EJS_threads = false;
            window.EJS_graphic = "webgl";
            window.EJS_webgl2 = true;
            
            window.EJS_onSaveState = function(data) {
                console.log("âš¡ [Hook] EJS_onSaveState called.", data);
                
                let blob = null;
                if (data instanceof Uint8Array) {
                    blob = data;
                } else if (data && data.state instanceof Uint8Array) {
                    blob = data.state;
                } else if (data && typeof data === 'object') {
                    blob = Object.values(data).find(v => v instanceof Uint8Array);
                }

                if (blob) {
                    const key = window.EJS_gameName + ".state";
                    
                    LocalStateStore.save(key, blob).then(success => {
                        if(success === true) console.log("âœ… DB Save Success");
                        else console.error("âŒ DB Save Failed");
                    });
                    
                    showToast("ğŸ’¾ ìƒíƒœ ì €ì¥ ì™„ë£Œ!");
                }
                return true; 
            };

            window.EJS_onLoadState = async function() {
                const key = window.EJS_gameName + ".state";
                try {
                    const data = await LocalStateStore.load(key);
                    if (data) {
                        showToast("ğŸ“‚ ìƒíƒœ ë¡œë“œ ì™„ë£Œ!");
                        return data; 
                    } else {
                        showToast("âš ï¸ ì €ì¥ëœ ìƒíƒœê°€ ì—†ìŠµë‹ˆë‹¤.", true);
                        return null;
                    }
                } catch(e) {
                    console.error(e);
                    return null;
                }
            };
            
            window.EJS_startOnLoaded = true;
            window.EJS_fullscreenOnLoaded = false;
            window.EJS_backgroundColor = '#000'
            
            const coreVersion = localStorage.getItem('coreVersion') || Date.now();
            const loader = document.createElement('script');
            loader.id = 'ejs-loader';
            loader.src = window.EJS_pathtodata + "loader.js?v=" + coreVersion;

            this.setupEventHandlers();

            document.body.appendChild(loader);
        },

        cleanup: function() {
            const btnRefresh = document.getElementById('refresh-btn');
            const btnFS = document.getElementById('fs-check-btn');
            const view = document.getElementById('game-view');
            
            if(view) {
                if(btnRefresh && btnRefresh.parentElement !== view) view.appendChild(btnRefresh);
                if(btnFS && btnFS.parentElement !== view) view.appendChild(btnFS);
            }

            try {
                if(window.EJS_emulator?.audio?.context) {
                    window.EJS_emulator.audio.context.suspend();
                    window.EJS_emulator.audio.context.close();
                }
            } catch(e){}

            try {
                const gameDiv = document.getElementById('game');
                if (gameDiv) gameDiv.innerHTML = '';
                const loader = document.getElementById('ejs-loader');
                if (loader) loader.remove();

                window.EJS_emulator = null;
                window.EJS_gameName = null;
                window.EJS_onSaveState = null;
                window.EJS_onLoadState = null;
            } catch(e) { console.error("Cleanup error:", e); }
        },

        setupEventHandlers: function() {
            window.EJS_ready = () => {
                console.log("âœ… [EJS] Core Ready.");
                if (window.EJS_emulator) {
                    window.EJS_emulator.on("save", this.handleGameSave);
                }
            };

            window.EJS_onGameStart = () => {
                console.log("ğŸš€ [EJS] Game Started!");
                
                try {
                    const FS = window.EJS_emulator.Module.FS;
                    const dirs = [
                        '/home/web_user/retroarch', 
                        '/home/web_user/retroarch/userdata', 
                        '/home/web_user/retroarch/userdata/states'
                    ];
                    
                    dirs.forEach(dir => {
                        try {
                            try { FS.stat(dir); } catch(e) { FS.mkdir(dir); console.log("Created dir:", dir); }
                        } catch(e) { console.warn("Dir check failed:", dir); }
                    });
                } catch(e) {
                    console.error("FS Init Error:", e);
                }

                setTimeout(() => {
                    const canvas = document.querySelector("#game canvas");
                    if (canvas) { canvas.tabIndex = 0; canvas.focus(); } 
                    else window.focus();
                }, 100);

                setTimeout(() => {
                    const btnRefresh = document.getElementById('refresh-btn');
                    const btnFS = document.getElementById('fs-check-btn');
                    const gameDiv = document.getElementById('game');
                    if(gameDiv) {
                        if(btnRefresh) gameDiv.appendChild(btnRefresh);
                        if(btnFS) gameDiv.appendChild(btnFS);
                    }
                }, 500);

                setTimeout(() => {
                    this.injectSaveData(true);
                    setTimeout(() => this.startSaveMonitor(), 2000);
                }, 1000);
            };
        },

        startSaveMonitor: function() {
            if (this.monitorInterval) clearInterval(this.monitorInterval);
            this.monitorInterval = setInterval(async () => {
                if (document.hidden) return;
                if (this.isSaving || !window.EJS_emulator?.Module?.FS || !this.currentSavePath) return;
                
                try {
                    const FS = window.EJS_emulator.Module.FS;
                    const stat = FS.stat(this.currentSavePath);
                    const currentMtime = stat.mtime.getTime();

                    if (this.lastSaveMtime === 0) {
                        this.lastSaveMtime = currentMtime;
                        return;
                    }

                    if (currentMtime > this.lastSaveMtime) {
                        console.log("ğŸ’¾ [Monitor] Change detected. Syncing...");
                        this.lastSaveMtime = currentMtime;
                        await this.exportSave(true); 
                    }
                } catch (e) {}
            }, 30000); 
        },

        injectSaveData: async function(shouldReload = false) {
            const serverFilename = window.EJS_gameName + ".sav";
            const data = await this.fetchSaveData(serverFilename);
            
            if (window.EJS_emulator?.Module?.FS) {
                const FS = window.EJS_emulator.Module.FS;
                const romFull = window.EJS_gameUrl.split('/').pop(); 
                const romName = romFull.replace(/\.[^/.]+$/, "");
                const coreFolder = CORE_FOLDER_MAP[window.EJS_core] || window.EJS_core;
                const targetPath = `/data/saves/${coreFolder}/${romName}.srm`;
                this.currentSavePath = targetPath;

                if (data) {
                    try { FS.mkdir('/data'); FS.mkdir('/data/saves'); FS.mkdir(`/data/saves/${coreFolder}`); } catch(e){}
                    try {
                        FS.writeFile(targetPath, data);
                        try { this.lastSaveMtime = FS.stat(targetPath).mtime.getTime(); } catch(err) { this.lastSaveMtime = Date.now(); }
                    } catch(e) { console.error("Write failed:", e); }

                    if (shouldReload) {
                        if(window.EJS_emulator.gameManager?.loadSaveFiles) window.EJS_emulator.gameManager.loadSaveFiles();
                        showToast(`ğŸ“‚ ì„¸ì´ë¸Œ ë™ê¸°í™” ì™„ë£Œ\n(${coreFolder}/${romName}.srm)`);
                    }
                } else { console.log("âš ï¸ ìƒˆ ê²Œì„ ì‹œì‘"); }
            }
        },

        exportSave: async function(skipFlush = false) {
            if (!window.EJS_emulator?.gameManager) return;
            if (this.isSaving) return; 
            
            this.isSaving = true;

            try {
                if (!skipFlush && window.EJS_emulator.gameManager.saveSaveFiles) window.EJS_emulator.gameManager.saveSaveFiles();
                
                const data = window.EJS_emulator.gameManager.getSaveFile();
                if (!data) { 
                    if(!skipFlush) showToast("âš ï¸ ì €ì¥í•  ë°ì´í„° ì—†ìŒ", true); 
                    return; 
                }

                const success = await this.uploadSaveData(window.EJS_gameName + ".sav", data);
                if (success) {
                    if (skipFlush) showToast("â˜ï¸ ìë™ ë™ê¸°í™” ì™„ë£Œ");
                    else showToast("âœ… ì„œë²„ ì €ì¥ ì™„ë£Œ!");
                } else { showToast("âŒ ì„œë²„ ì €ì¥ ì‹¤íŒ¨", true); }
            } catch (e) { 
                console.error("Export Error:", e); 
            } finally {
                this.isSaving = false; 
            }
        },

        handleGameSave: async function(event) {
            let data = event.content || event;
            if (!data) return;
            if(await Launcher.uploadSaveData(window.EJS_gameName + ".sav", data)) showToast("ğŸ’¾ ìë™ ì €ì¥ ì™„ë£Œ!");
        },

        uploadSaveData: async function(filename, data) {
            try {
                await fetch(`/api/save?name=${encodeURIComponent(filename)}`, { method: 'POST', body: data });
                return true;
            } catch (e) { return false; }
        },

        fetchSaveData: async function(filename) {
            try {
                const res = await fetch(`/api/load?name=${encodeURIComponent(filename)}&t=${Date.now()}`);
                if (!res.ok) return null;
                const buf = await res.arrayBuffer();
                return new Uint8Array(buf);
            } catch (e) { return null; }
        }
    };
	
    window.addEventListener('keydown', (e) => {
        if (e.key === "Escape") {
            if (App.inGame) {
                e.preventDefault(); e.stopPropagation();
                App.closeGame();
            }
        } else if (e.key === "F5") {
             e.preventDefault(); e.stopPropagation();
             location.reload();
        }
    }, { capture: true });

    App.init();
</script>
</body>
</html>